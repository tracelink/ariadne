package com.tracelink.appsec.ariadne.read.vulnerability;

import com.opencsv.CSVReader;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

/**
 * Reads CSV files containing issues exported from Veracode SCA. Used to identify vulnerable
 * libraries and the number of times they are used in code.
 *
 * @author mcool
 */
public class VeracodeScaIssuesReader implements VulnerabilityReader {

	private final File file;

	public VeracodeScaIssuesReader(String path) throws FileNotFoundException {
		file = new File(path);
		if (!file.exists() || file.isDirectory()) {
			throw new FileNotFoundException(
					"Please provide a valid path to the Veracode SCA issues data");
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public List<Entry<String, Integer>> readVulnerabilities() throws IOException {
		Map<String, Integer> vulnerabilityMap = new HashMap<>();
		try (BufferedReader fileReader = new BufferedReader(new FileReader(file))) {
			for (String[] row : new CSVReader(fileReader)) {
				// Skip the header row at top of file
				if (Arrays.asList(row).contains("Issue ID")) {
					continue;
				}
				// Concatenate the full, vulnerable library name
				String fullName = String.join(":", row[9], row[10], row[6]);
				// Add vulnerable library to map if it doesn't already exist
				if (vulnerabilityMap.containsKey(fullName)) {
					vulnerabilityMap.put(fullName, vulnerabilityMap.get(fullName) + 1);
				} else {
					vulnerabilityMap.put(fullName, 1);
				}
			}
		}
		// Return vulnerability counts as list
		List<Map.Entry<String, Integer>> vulnerabilities = new ArrayList<>();
		vulnerabilityMap.forEach((String key, Integer value) -> vulnerabilities
				.add(new AbstractMap.SimpleEntry<>(key, value)));
		return vulnerabilities;
	}
}
